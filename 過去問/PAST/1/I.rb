n,m = gets.split.map(&:to_i)

def change_to_bit(s)
  s.gsub!("Y","1")
  s.gsub!("N","0")
  s.to_i(2)
end

dp = [-1] * 9
dp[0] = 0
m.times do
	s, c = gets.split(' ')
	s = change_to_bit(s)
	c = c.to_i
	8.downto(0) do |i|
		next if dp[i] == -1
		dp[i | s] = dp[i] + c if dp[i | s] == -1 or dp[i | s] > dp[i] + c
	end
end

p dp[("1"*n).to_i(2)]

# 例えば、下のとき
# 3 4
# YYY 100 => YYY -> 111
# YYN 20  => YYN -> 110
# YNY 10  => YNY -> 101
# NYY 25  => NYY -> 011
#
# 後ろから順にdpを調べて、-1でないところを見つけたら、
# そのdpのindexと、その時のbitのORの位置の値を更新する。(そのセットを選択するという意味を表す)
# そのとき更新する条件は-1(未更新)もしくは、既存より値が小さい場合。
#
# i 0,001,010,011,100,101,110, 111 <= 2進数表記
#  [0, -1, -1, -1, -1, -1, -1, 100, -1,...] <= dp[0]!=-1より,0|111=111の値を0+100で更新
#  [0, -1, -1, -1, -1, -1, 20, 100, -1,...] <= dp[111]!=-1より,111|111=111の値を100+20で更新しようとするも大きくなるので何もしない
#                                              dp[0]!=-1より,0|110=110の値を0+20で更新
#  [0, -1, -1, -1, -1, 10, 20, 30, -1,...] <= dp[111]!=-1より,111|101=111の値を100+10で更新しようとするも...
#                                             dp[110]!=-1より,110|101=111の値を20+10で更新
#                                             dp[0]!=-1より,0|101=101の値を0+10で更新
#  [0, -1, -1, 25, -1, 10, 20, 30, -1,...] <= dp[111]!=-1より,111|011の値を30+25更新しようとするも...
#                                             dp[110]!=-1より,110|011の値を20+25で更新しようとするも...
#                                             dp[101]!=-1より,101|011の値を10+25で更新しようとするも...
#                                             dp[0]!=-1より,0|011の値を0+25で更新
